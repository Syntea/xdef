Letter ::= $letter
Char ::= $xmlChar
WhiteSpace ::= $whitespace
Comment ::= "/*" ( [^*]+ | "*" [^/] )* "*/"
S ::= ( WhiteSpace | Comment )+

/***************************************************************************** 
* Base symbols
******************************************************************************/

Keyword ::=
  "if" | "else" | "do" | "while" | "continue" | "break" | "switch" | "case" |
  "for" | "return" | "def" | "try" | "catch" | "throw" | "finally" |
  "external" | "new" | "fixed" | "required" | "optional" | "ignore" |
  "illegal" | "occurs" | "onTrue" | "onError" | "onAbsence" | "default" |
  "onExcess" | "onStartElement" | "onIllegalAttr" | "onIllegalText" |
  "onIllegalElement" | "onIllegalRoot" | "create" | "init" | "options" |
  "ref" | "match" | "final" | "forget" | "template" | "type" | "uniqueSet" | 
  "EQ" | "NE" | "LT" | "LE" | "GT" | "GE" |
  "LSH" | "RSH" | "RRSH" | "AND" | "OR" | "XOR" | "MOD" | "NOT" | "NEG" |
  "OOR" | "AAND" |
  "true" | "false" |
  "$PI" | "$E" | "$MAXINT" | "$MININT" | "$MINFLOAT" | "$MAXFLOAT" |
  "$NEGATIVEINFINITY" | "$POSITIVEINFINITY"

Digit ::= [0-9]

Identifier ::= (BaseIdentifier ( ':' BaseIdentifier)? ) - Keyword

BaseIdentifier ::= (( Letter | "_" | "$")  ( Letter | Digit | "_" )*)

RawIdentifier ::= ( Letter | "_")  ( Letter | Digit | "_" )*

QualifiedIdentifier ::= BaseIdentifier ( "." BaseIdentifier )+ | BaseIdentifier

BooleanLiteral ::= "true" | "false"

DecimalInteger ::= ( Digit ("_")* )+

HexaDigit ::= Digit | [a-fA-F]

IntegerLiteral ::= DecimalInteger | ( "0x" | "0X" ) (HexaDigit ("_")* )+
/* Inside a number specification it is possible to insert the character "_".
  This character does not influence the value of the number, it just makes 
  a number more readable. E.g. the number 123456789 you can be written
  as 123_456_789 (or 0x0f123456 as 0x0f_12_34_56). */

NumberLiteral ::= 
  DecimalInteger ( "." DecimalInteger )? ( ("E" | "e") [-+]? DecimalInteger )?

SpecChar ::= 
  "\" ("\" | '"' | "'" | "n" | "r" | "t" ) | UnicodeCharSpecification

UnicodeCharSpecification ::= "\u" HexaDigit{4}

StringLiteral ::= "'" ( "''" | [^'\] | SpecChar)* "'" |
  '"' ( '""' | [^"\] | SpecChar)* '"'
  /* The opening and closing delimiter must be either """ or "'". The occurrence
     of this delimiter inside of literal can be recorded as double delimiter or
     in the form of SpecChar. */

Literal ::= BooleanLiteral | NumberLiteral | StringLiteral

XMLName ::= $xmlName /* XMLName see XML specification */

KeyName ::= "%" XMLName

AttributeName ::= "@" XMLName

Reference ::= "ref" S XPosition

XDefName ::= XMLName

XModelName ::= XMLName

XPosition ::= (XDefName? "#")? XModelName
  ("/" (XMLName | XGroupRererence | XAnyReference) XPositionIndex? )*
  ("/" ( XAttrReference | XTextReference ) )?

XPositionIndex ::= "[" Digit+ "]"

XGroupRererence ::= "$mixed" | "$choice" | "$sequence"

XAnyReference ::= "$any"

XAttrReference ::= "@" XMLName

XTextReference ::= "$text" XPositionIndex?

RootList ::= S? RootSpecification ( S? "|" S? RootSpecification )* S?
  /* all rootspecification in the list must be unique */

RootSpecification ::= XPosition | "*"

MethodListItem ::= Identifier S? 
  QualifiedIdentifier S? "(" S? MethodListItemParamList? S? ")" S?
  ("as" S? Identifier)? S? ";"
  
MethodListItemParamList ::= QualifiedIdentifier (S?"[" S? "]")?
  (S? "," S? QualifiedIdentifier (S?"[" S? "]")?)*

MacroReference ::= "${" S? XMLName S? MacroParams? S? "}"

MacroParams ::= "(" S? Identifier ( S? "," S? Identifier)* S? ")"

/***************************************************************************** 
* Script expression
******************************************************************************/

Expression ::= Expr1 (S? "?" S? Expression S? ":" S? Expression )?

OperatorLevel_1 ::= "OR" | "OOR" | "XOR" | "||" | "|" | "^"

Expr1 ::= Expr2 (S? OperatorLevel_1 S? Expr2 )*

OperatorLevel_2 ::= "AND" | "AAND" | "&&" | "&"

Expr2 ::= Expr3 (S?  OperatorLevel_2 S? Expr3 )*

OperatorLevel_3 ::=
  "LT" | "<" | "GT" | ">" | "==" | "EQ" | "LE" | "<=" | "GE" |
  ">=" | "!=" | "NE" | "<<" | "LSH" | ">>" | "RSH" | ">>>" | "RRSH"

Expr3 ::= Expr4 (S? OperatorLevel_3 S? Expr4 )*

OperatorLevel_4 ::= "*" | "/" | "%"

Expr4 ::= Expr5 (S? OperatorLevel_4 S? Expr5 )*

OperatorLevel_5 ::= "+" | "-"

Expr5 ::= Expr (S? OperatorLevel_5 S? Expr )*

Expr ::= (UnaryOperator S? | CastRequest S?)*
  (Value | Literal | "(" S? Expression S? ")") (S? "." S? Method)?

ConstantExpression ::= Literal /* ConstantExpression must be a Literal. */

CastRequest ::= S? "(" S? TypeIdentifier S? ")" S?

UnaryOperator ::= "+" | "-" | "!" | "NOT" | "~"

TypeIdentifier ::= "int" | "String" | "float" | "boolean" | "Datetime" |
  "Decimal" | "Duration" | "Exception" | "Container" | "Element" | "Message" |
  "Bytes" | "XmlOutStream" | "BNFGrammar" | "BNFRule" | "Parser" |
  "ParseResult" | "AnyValue"

Value ::= Constructor | "null" | Method | Increment | VariableReference |
  KeyParameterReference | Literal | AttributeName |
  "$MAXINT" | "$MININT" |
  "$MINFLOAT" | "$MAXFLOAT" |"$NEGATIVEINFINITY" | "$POSITIVEINFINITY" |
  "$PI" | "$E"

Constructor ::= "new" S TypeIdentifier S? "(" S? ParameterList? S? ")" |
  NamedValue | ContainerValue

NamedValue ::= KeyName S? "=" S? Expression

ContainerValueStart ::= (NamedValue (S? "," S? NamedValue)*) | Expression

ContainerValue ::= "[" S? (ContainerValueStart (S? "," S? Expression)*)? S? "]"

KeyParameterReference ::= KeyName

Method ::= QualifiedIdentifier S? ("(" S? ParameterList? S? ")")?

Increment ::=
  ("++" | "--") S? VariableReference | VariableReference S? ("++" | "--")
  /* The variable must be declared as an integer or a float */

ParameterList ::= (Expression) (S? "," S? Expression)*

VariableReference ::= Identifier - TypeIdentifier

MethodDeclaration ::=
  ( "void" | TypeIdentifier ) S MethodName S? ParameterListDeclaration S? Block

MethodName ::= QualifiedIdentifier

ParameterListDeclaration ::=
  "(" S? ( SeqParameter (S? "," S? SeqParameter )* )? ")"

SeqParameter ::= TypeIdentifier S ParameterName

KeyParameter ::= KeyName S? "=" S? (TypeIdentifier | ConstantExpression)

ParameterName ::= Identifier

ParentalExpression ::= S? "(" S? Expression S? ")" S?

StatementExpression ::= Expression

/***************************************************************************** 
* Script statement
******************************************************************************/

Statement ::= S? (Statement1 | Statement2)

Statement1 ::= Block | SwitchStatement | TryStatement 

Statement2 ::= ( IfStatement | ForStatement | WhileStatement | DoStatement | 
  ReturnStatement | ThrowStatement | BreakStatement | ContinueStatement |
  Method | Increment | AssignmentStatement S? ";" ) | EmptyStatement

EmptyStatement ::= ";"

StatementSequence ::= ( S? VariableDeclaration S? ";" | Statement)*

Block ::= "{" StatementSequence S? "}"

SimpleStatement ::= S? (Statement1 | (Statement2? S? ";" S?)) | EmptyStatement

IfStatement ::=
  "if" ParentalExpression SimpleStatement ( S? "else" S? SimpleStatement)?
  /* Result of ParentalExpression must be boolean. */

ForStatement ::= "for" S? "(" S?  ForInit? S? ";" S? 
  Expression? S? ";" S? ForStep? S? ")" S? SimpleStatement

ForInit ::= AssignmentStatement | VariableDeclaration

ForStepStatement ::= Method | Increment | AssignmentStatement

ForStep ::= ForStepStatement (S? "," S? ForStepStatement)*

WhileStatement ::= "while" ParentalExpression SimpleStatement
  /* Result of ParentalExpression must be boolean. */

DoStatement ::= "do" S? Statement S? "while" ParentalExpression
  /* Result of ParentalExpression must be boolean. */

SwitchStatement ::=
  "switch" ParentalExpression "{" SwitchBlockStatementVariant* S? "}"
  /* Result of ParentalExpression must be integer. Any variant may occur in the
     switch statement only once. */

SwitchBlockStatementVariant ::=
   S? ("default" | "case" S? ConstantExpression) S? ":" S? StatementSequence?
  /* Type  of ConstantExpression must be integer. */

ThrowStatement ::= "throw" S? ExceptionValue

ExceptionValue ::=
  "new" S? "Exception" S? "(" S? (Expression S?)? ")" | Identifier

TryStatement ::= "try" S? "{" S? StatementSequence S? "}" S? 
  "catch" S? "(" S? "Exception" S?  Identifier S? ")" S?
  "{" S? StatementSequence S? "}"

ReturnStatement ::= "return" (S? Expression)?

BreakStatement ::= "break" (S? Identifier)?

ContinueStatement ::= "continue" (S? Identifier)?

AssignmentStatement ::= Identifier S? ((AssignmentOperator S? Expression) |
 (("=" S? Identifier))+ S? (AssignmentOperator S? Expression)) |
  S? AssignmentOperator S? Expression

AssignmentOperator ::= 
  ("|" | "^" | "+" | "-" | "*" | "/" | "&" | "%") "=" | "="

VariableDeclaration ::= ("final" S | "external" S )*
  TypeIdentifier S VariableDeclarator (S? "," VariableDeclarator)*

VariableDeclarator ::= S? (AssignmentStatement | Identifier)

Occurrence ::= "required" | "optional" | "ignore" | "illegal" |"*" | "+" | "?"
	| (("occurs" S)? ("*" | "+" | "?" |
  (IntegerLiteral (S? ".." (S? ( "*" | IntegerLiteral))? )?)))
  /* The value of the second IntegerLiteral (after "..")  must be greater or
     equal to the first one. */

ExplicitCode ::= Block
  /* If result value is required it must be returned by the command
     "return value". */

/***************************************************************************** 
* Script of header of X-definition
******************************************************************************/

XdefScript ::=
  S? ( XdefInitSection | XdefOnIllegalRoot | XdefOnXmlError | XdefOptions )* S?
  /* Each item can be specified only once. */

XdefInitSection ::= "init" S Statement

XdefOnIllegalRoot ::= "onIllegalRoot" S Statement

XdefOnXmlError ::= "onXmlError" S Statement

XdefOptions ::= "options" S XdefOptionsList

XdefOptionsList ::= XdefOptionItem ( S? "," S? XdefOptionItem )*
  /* Each item can be specified only once. */

XdefOptionItem ::=
  "moreAttributes" | "moreElements" | "moreText" |
  "forget" | "notForget" | "clearAdoptedForgets" |
  "resolveEntities" | "ignoreEntities" |
  "resolveIncludes" | "ignoreIncludes" |
  "preserveComments" | "ignoreComments" |
  "acceptEmptyAttributes" |
  "preserveEmptyAttributes" | "ignoreEmptyAttributes" |
  "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces" |
  "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces" |
  "setAttrUpperCase" | "setAttrLowerCase" |
  "setTextUpperCase" | "setTextLowerCase" |
  "acceptQualifiedAttr" | "notAcceptQualifiedAttr" |
  "trimAttr" | "noTrimAttr" |
  "trimText" | "noTrimText" |
  "resolveEntities" | "ignoreEntities" |
  "resolveIncludes" | "ignoreIncludes" |
  "preserveComments" | "ignoreComments"

/***************************************************************************** 
* Script of text nodes and attributes
******************************************************************************/

AttributeScript ::= ValueScript

ValueScript ::= ValueExecutivePart*

ValueExecutivePart::= S? ( ValueValidationSection | ValueInitSection | 
  ValueOnTrueSection | ValueOnErrorSection | ValueOnAbsenceSection |
  ValueDefaultSection | ValueCreateSection | ValueFinallySection |
  AttributeOptions | Reference | S | ";" ) S?
  /* Each item can be specified only once. */

ValueValidationSection ::=
 (Occurrence S? CheckValueSpecification?) | CheckValueSpecification

CheckValueSpecification ::= ExplicitCode | Expression | TypeMethodName
  /* Expression or ExplicitCode must return a value of boolean type. */

TypeMethodName ::= Identifier

ValueInitSection ::= "init" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnTrueSection ::= "onTrue" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnErrorSection ::= "onError" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnAbsenceSection ::= "onAbsence" S ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueCreateSection ::= "create" S? ( ExplicitCode | Expression )
  /* Expression nebo ExplicitCode must return the value of String. */

ValueDefaultSection ::= "default" S? ( ExplicitCode | Expression )
  /* Expression nebo ExplicitCode must return the value of the String. */

ValueFinallySection ::= "finally" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

AttributeOptions ::= ValueOptions

ValueOptions ::= "options" S? ValueOptionsList

ValueOptionsList ::=  ValueOption ( S? "," S? ValueOption )*
  /* Each item can be specified only once. */

ValueOption ::= "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces" |
  "setTextUpperCase" | "setTextLowerCase" | "trimText" | "noTrimText" |
  "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces" |
  "setAttrUpperCase" | "setAttrLowerCase" | "trimAttr" | "noTrimAttr"
  
/***************************************************************************** 
* Script of elements
******************************************************************************/

ElementScript ::= ElementExecutivePart*

ElementExecutivePart ::= S? ( Occurrence | ElementVarSection |
  ElementMatchSection| ElementInitSection | ElementOnAbsenceSection | 
  ElementOnExcessSection | ElementCreateSection | ElementFinallySection |
  ElementOptions | Reference | ElementForgetSection | ElementOnStartSection |
  S | ";" )
  /* Each item can be specified only once. 
   * If the occurrence is not specified, the implicite value is "required" */

ElementVarSection ::= "var" S? 
  (("{"(S? ElementVarSectionItem S?)* "}") | ElementVarSectionItem S?)
  
ElementVarSectionItem ::= TypeDeclaration | VariableDeclaration S? ";"  | S? ";"

ElementInitSection ::= "init" S? Statement?

ElementMatchSection ::= "match" S? ( Expression | ExplicitCode )
  /* Expression nebo ExplicitCode must return value of boolean. */

ElementOnStartSection ::= "onStartElement" S? Statement?

ElementOnExcessSection ::= "onExcess" S? Statement?

ElementOnAbsenceSection ::= "onAbsence" S? Statement?

ElementCreateSection ::= "create" S? (Expression | ExplicitCode)
  /* Expression nebo ExplicitCode must return value of Container or Element. */

ElementFinallySection ::= "finally" S? Statement?

ElementForgetSection ::= "forget"

ElementOptions ::= "options" S? ElementOptionsList

ElementOptionsList ::=  ElementOptionItem ( S?  "," S? ElementOptionItem )*
  /* Each item can be specified only once. */

ElementOptionItem ::= "moreAttributes" | "moreElements" | "moreText" |
  "forget" | "notForget" | "acceptEmptyAttributes" | "clearAdoptedForgets" |
  "preserveEmptyAttributes" | "ignoreEmptyAttributes" |
  "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces" |
  "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces" | "setAttrUpperCase" |
  "setAttrLowerCase" | "setTextUpperCase" | "setTextLowerCase" |
  "acceptQualifiedAttr" | "notAcceptQualifiedAttr" | "trimAttr" | "noTrimAttr" |
  "trimText" | "noTrimText" | "resolveEntities" | "ignoreEntities" |
  "resolveIncludes" | "ignoreIncludes" | "preserveComments" | "ignoreComments" |
  "nillable" | "noNillable"

/***************************************************************************** 
* Script of the declaration part
******************************************************************************/

DeclarationScript ::= (S? (TypeDeclaration | ExternalMethodDeclaration
  | VariableDeclaration S? ";" | MethodDeclaration |  ";"))* S?

TypeDeclaration ::= ("type" S Identifier S?
  ( (Identifier (S? "," S? Identifier)* S? ";" S?) | TypeDeclarationBody ))
  | ("uniqueSet" S Identifier S?  UniqueSetDeclarationBody )

TypeDeclarationBody ::= Expression
  /* Expression or ExplicitCode must return value of boolean or ParseResult.*/

ExternalMethodDeclaration ::= "external" S "method" 
  (S MethodListItem | (S? "{" (S? MethodListItem)* S? "}" ))

UniqueSetDeclarationBody ::= ("{" S? Identifier S? ":" S? "?"? S? Expression
  (S? ";" S? S? Identifier S? ":" S? "?"? S? Expression)? S? ";"? S? "}")
  | Expression
  /* Expression or ExplicitCode must return value of boolean or ParseResult.*/

/***************************************************************************** 
 * BNF grammar
 ******************************************************************************/

BNFGrammar ::= S? BNFMethodDeclarationSection? S? BNFRules S?

BNFMethodDeclarationSection ::= BNFMethodDeclaration (S? BNFMethodDeclaration)*

BNFRuleName ::= RawIdentifier

BNFExternalRuleName ::= "$" BNFRuleName

BNFRuleReference ::= BNFExternalRuleName | BNFRuleName

BNFMethodDeclaration ::= "%define" S BNFExternalRuleName S ":"
 S "$" QualifiedIdentifier BNFMethodparameters?

BNFMethodparameters ::= "(" S? BNFMethodparameter
 (S? "," S? BNFMethodparameter)* S? ")"

BNFMethodparameter ::= Digit+ | BNFTerminalSymbol

BNFTerminalSymbol ::= "'" (Char - "'")* "'" | '"' (Char - '"')* '"' 
  | BNFHexaChracter (S? BNFHexaChracter)*

BNFHexaChracter ::= "#x" HexaDigit+

BNFRules ::= BNFRule (S BNFRule)*

BNFRule ::= BNFRuleName S? "::=" S? BNFExpression

BNFQuantificator ::= S? ("+" | "*" | "?" | BNFExplicitQuantificator)

BNFExplicitQuantificator ::= "{" S? Digit+ (S? "," S? Digit+)? S? "}" 

BNFExpression ::= ( "(" S? BNFExpression  S? ")" (S? BNFQuantificator)?
  | BNFRestriction | BNFSelection | BNFSequence ) - ( BNFRuleName S? "::=" )

BNFSet ::= "[" BNFSetBody "]"

BNFSetBody ::= ("^"? Char - "]")+

BNFTerm ::= (BNFTerminalSymbol | BNFSet | BNFRuleReference)
  (S? BNFQuantificator)?

BNFSequence ::= BNFTerm ( S BNFExpression )*

BNFRestriction ::= BNFTerm S? "-" S? BNFExpression

BNFSelection ::= BNFTerm ( S? "|" S? BNFExpression )+

/***************************************************************************** 
* XComponent
******************************************************************************/

JavaTypeName ::= '<' S? $JavaQName (S? JavaTypeName )? (S? "," S?  JavaTypeName)* S? '>'

JavaTypedQName ::= $JavaQName ( S? JavaTypeName )?

/*JavaTypeName ::= '<' $JavaQName JavaTypeName* ("," JavaTypeName)* '>'

JavaTypedQName ::= $JavaQName JavaTypedQName?*/

XCComponent ::= ( S? XCComponentCommand )* S?

XCComponentCommand ::= ( XCBind | XCClass | XCEnum | XCInterface | XCRef ) S? ";"

XCBind ::= "%bind" S XMLName ( S "%with" S $JavaQName )? S XCLink

XCClass ::= "%class" S JavaTypedQName (S "extends" S JavaTypedQName )?
  (S "implements" S JavaTypedQName (S? "," S? JavaTypedQName)*)?
  (S "%interface" S JavaTypedQName)?
  S XCLink

XCEnum ::= "%enum" S JavaTypedQName S (Identifier? "#")? XMLName

XCInterface ::= "%interface" S $JavaQName S XCLink

XCRef ::= "%ref" S $JavaQName S $JavaQName S XCLink

XCLink ::= "%link" S ("*" /*any*/ | XPosition)
