<?xml version="1.0" encoding="UTF-8"?>
<!-- Metanamespace of XDefinition: "METAXD" is 3.1 -->
<xd:def xmlns:xd  = "METAXD"
  xmlns:w         = "http://www.syntea.cz/xdef/3.1"
  xmlns:XD2.0     = "http://www.syntea.cz/xdef/2.0"
  xmlns:XD3.1     = "http://www.syntea.cz/xdef/3.1"
  w:metaNamespace = "METAXD"
  xd:root         = "Ver2.0#XD2.0:def | Ver2.0#XD2.0:collection 
                     | Ver3.1#XD3.1:def | Ver3.1#XD3.1:collection" >

<xd:declaration>
  /* Default namespace of XDefinition */
  String xdUri;
  /* Variable id used as the namespace of checked source; default is xdUri.*/
  String NS;

/******************************************************************************/
/* Types of values see BNF grammar below                                      */
/******************************************************************************/
  type rootList XDScript.rule('RootList');
  type xdefScript XDScript.rule('XdefScript');
  type declarationScript XDScript.rule('DeclarationScript');
  type valueScript XDScript.rule('ValueScript');
  type attributeScript XDScript.rule('AttributeScript');
  type elementScript XDScript.rule('ElementScript');
  type groupScript XDScript.rule('ElementScript');
  type groupModelScript XDScript.rule('ElementScript');
  type Occurrence XDScript.rule('Occurrence');
  type elementCreateSection XDScript.rule('ElementCreateSection');
  type elementCreateCode XDScript.rule('ElementCreateCode');
  type xdIdentifier XDScript.rule('Identifier');
  type xposition XDScript.rule('XPosition');
  type booleanLiteral XDScript.rule('BooleanLiteral');
  type bnfGrammar XDScript.rule('BNFGrammar');
  type xcomponent XDScript.rule('XCComponent');

  /** Check element name and namespace URI (used in the match section) */
  boolean xdName(String name) {
    return getElementLocalName() EQ name AND getNamespaceURI() EQ NS;
  }
</xd:declaration>

/******************************************************************************/
/* Declaration of BNF grammar of Script                                       */
/******************************************************************************/

  <xd:BNFGrammar name = "XDScript">
<![CDATA[
/******************************************************************************/
/* Generatied codes                                                           */
/******************************************************************************/
%define $PUS: $push()     /* put parsed source to internal stack. */
%define $INF: $info()     /* put actual source position to internal stack. */

%define $OPA: $push('OPA') /* assignment operation */
%define $AVE: $push('AVE') /* assigned value in expression */
%define $OPU: $push('OPU') /* unary operators */
%define $OP1: $push('OP1') /* operators level 1 */
%define $OP2: $push('OP2') /* operators level 2 */
%define $OP3: $push('OP3') /* operators level 3 */
%define $OP4: $push('OP4') /* operators level 4 */
%define $OP5: $push('OP5') /* operators level 5 */
%define $TYP: $push('TYP') /* name the type of a value */
%define $CON: $push('CON') /* constant name */
%define $NUL: $push('NUL') /* null */
%define $NEW: $push('NEW') /* new */
%define $VRF: $push('VRF') /* variable reference */
%define $MET: $push('MET') /* method name (before parameter list) */
%define $PAR: $push('PAR') /* method parameter */
%define $CAL: $push('CAL') /* method call (end of parameter list) */
%define $NMI: $push('NMI') /* integer number */
%define $NMF: $push('NMF') /* floating point number */
%define $TRU: $push('TRU') /* true */
%define $FAL: $push('TRU') /* false */
%define $STR: $push('STR') /* string literal */
%define $INB: $push('INB') /* increase before: ("++") variable */
%define $INA: $push('INA') /* increase after: variable ("++") */
%define $DEB: $push('DEB') /* decrease before: ("--") variable */
%define $DEA: $push('DEA') /* decrease after: variable ("--") */

%define $FIN: $push('FIN') /* modifier "final" */
%define $EXT: $push('EXT') /* modifier "external" */

%define $FIX: $push('FIX') /* "fixed" value occurrence */

%define $ELE: $push('ELE') /* script of "xd:script" of element */
%define $OCC: $push('OCC') /* occurrence */

%define $SDM: $push('SDM') /* start of declared method */
%define $VOI: $push('VOI') /* void type of declared method */
%define $EDP: $push('EDP') /* end of declared method parameters */
%define $EDM: $push('EDM') /* end of declared method */

/******************************************************************************/
/* BNF grammar rules                                                          */
/******************************************************************************/

Letter ::= $letter

Char ::= $xmlChar

WhiteSpace ::= [#9#10#13 ]

Comment ::= "/*" ([^*]+ | "*" - "*/")* "*/"

S ::= (WhiteSpace | Comment)+

SemicolonOrSourceEnd ::= S? (";" S? | $eos)
/* Here at the end of the parsed source text the semicolon is not required. */

/******************************************************************************/ 
/* Base symbols                                                               */
/******************************************************************************/

Keyword ::= "if" | "else" | "do" | "while" | "continue" | "break" | "switch"
  | "case" | "for" | "return" | "def" | "try" | "catch" | "throw" | "finally"
  | "external" | "new" | "fixed" | "required" | "optional" | "ignore"
  | "illegal" | "occurs" | "onTrue" | "onError" | "onAbsence" | "default"
  | "onExcess" | "onStartElement" | "onIllegalAttr" | "onIllegalText" | "var"
  | "onIllegalElement" | "onIllegalRoot" | "create" | "init" | "options"
  | "ref" | "match" | "final" | "forget" | "template" | "type" | "uniqueSet"
  | "EQ" | "NE" | "LT" | "LE" | "GT" | "GE"
  | "LSH" | "RSH" | "RRSH" | "AND" | "OR" | "XOR" | "MOD" | "NOT" | "NEG"
  | "OOR" | "AAND"
  | "true" | "false" | "implements" | "extends"
  | "onFalse"
  
PredefinedConstant ::= "$PI" | "$E" | "$MAXINT" | "$MININT" | "$MINFLOAT"
  | "$MAXFLOAT" | "$NEGATIVEINFINITY" | "$POSITIVEINFINITY"

Digit ::= [0-9]

Identifier ::= BaseIdentifier - Keyword
/*Identifier ::= (BaseIdentifier (':' BaseIdentifier)? ) - Keyword*/

BaseIdentifier ::= ((Letter | "_" | "$")  (Letter | Digit | "_")* )

RawIdentifier ::= (Letter | "_")  (Letter | Digit | "_")*

QualifiedIdentifier ::= BaseIdentifier ("." BaseIdentifier)+ | BaseIdentifier

BooleanLiteral ::= ($TRU "true" | $FAL "false")

DecimalInteger ::= ("_"* Digit+)+ ("_")*

HexaDigit ::= Digit | [a-fA-F]

IntegerLiteral ::= $NMI (("0" [Dd])? DecimalInteger
  | "0" [Xx] ("_"* HexaDigit+)+ ("_")*) $PUS
/* Inside a number specification it is possible to insert the character "_".
  This character does not influence the value of the number, it just makes 
  a number more readable. E.g. the number 123456789 you can be written
  as 123_456_789 (or 0x0f123456 as 0x0f_12_34_56). */

FloatLiteral ::= $NMF (("0" [Dd]) DecimalInteger "." DecimalInteger? )
  | ((DecimalInteger ("." DecimalInteger Exponent? | Exponent))) $PUS 

Exponent ::= [Ee] [-+]? [0-9]+

NumberLiteral ::= FloatLiteral | IntegerLiteral

SpecChar ::= "\" ("\" | '"' | "'" | "n" | "r" | "t") | UnicodeCharSpecification

UnicodeCharSpecification ::= "\u" HexaDigit{4}

StringLiteral ::= $STR ("'" ("''" | [^'\] | SpecChar)* "'" |
  '"' ('""' | [^"\] | SpecChar)* '"') $PUS
  /* The opening and closing delimiter must be either """ or "'". The occurrence
     of this delimiter inside of literal can be recorded as double delimiter or
     in the form of SpecChar. */

Literal ::= BooleanLiteral | NumberLiteral | StringLiteral

XMLName ::= $xmlName /* XMLName see XML specification */

KeyName ::= "%" XMLName

AttributeName ::= "@" XMLName

Reference ::= "ref" S XPosition

XDefName ::= XMLName

XModelName ::= XMLName

XPosition ::= (XDefName? "#")? XModelName
  ("/" (XMLName | XGroupRererence | XAnyReference) XPositionIndex?)*
  ("/" (XAttrReference | XTextReference))?

XPositionIndex ::= "[" Digit+ "]"

XGroupRererence ::= "$mixed" | "$choice" | "$sequence"

XAnyReference ::= "$any"

XAttrReference ::= "@" XMLName

XTextReference ::= "$text" XPositionIndex?

RootList ::= S? RootSpecification (S? "|" S? RootSpecification)* S?
  /* all rootspecification in the list must be unique */

RootSpecification ::= XPosition | "*"

ExternalType ::= QualifiedIdentifier (S?"[" S? "]")?

MethodListItem ::= ExternalType S? 
  QualifiedIdentifier S? "(" S? MethodListItemParamList? S? ")" S?
  ("as" S? Identifier)?
  
MethodListItemParamList ::= ExternalType
  (S? "," S? QualifiedIdentifier (S?"[" S? "]")? )*

MacroReference ::= "$" "{" S? XMLName S? MacroParams? S? "}"

MacroParams ::= "(" S? Identifier (S? "," S? Identifier)* S? ")"

/******************************************************************************/
/* Script expression                                                          */
/******************************************************************************/

Expression ::= Expr1 (S? "?" S? Expression S? ":" S? Expression)?

OperatorLevel_1 ::= $OP2 ("AND" | "AAND" | "&&" | "&") $PUS

Expr1 ::= Expr2 (S? OperatorLevel_1 S? Expr2)*

OperatorLevel_2 ::= $OP1 ("OR" | "OOR" | "XOR" | "||" | "|" | "^") $PUS

Expr2 ::= Expr3 (S?  OperatorLevel_2 S? Expr3)*

OperatorLevel_3 ::= $OP3 ("LT" | "<" | "GT" | ">" | "==" | "EQ" | "LE"
  | "<=" | "GE" | ">=" | "!=" | "NE" | "<<" | "LSH" | ">>" | "RSH" | ">>>"
  | "RRSH") $PUS

Expr3 ::= Expr4 (S? OperatorLevel_3 S? Expr4)*

OperatorLevel_4 ::= $OP4 ("*" | "/" | "%") $PUS

Expr4 ::= Expr5 (S? OperatorLevel_4 S? Expr5)*

OperatorLevel_5 ::= $OP5 ("+" | "-") $PUS

Expr5 ::= Expr (S? OperatorLevel_5 S? Expr)*

Expr ::= (UnaryOperator S? | CastRequest S?)*
  (Value | Literal | "(" S? Expression S? ")") (S? "." S? Method)?

ConstantExpression ::= Literal /* ConstantExpression must be a Literal. */

CastRequest ::= S? "(" S? TypeIdentifier S? ")" S?

UnaryOperator ::= "+" | $OPU ("-" | "!" | "NOT" | "~") $PUS

TypeIdentifier ::= $TYP ("int" | "String" | "float" | "boolean" | "Datetime"
  | "Decimal" | "Duration" | "Exception" | "Container" | "Element" | "Message"
  | "Bytes" | "XmlOutStream" | "BNFGrammar" | "BNFRule" | "Parser" | "Service"
  | "ResultSet" | "Statement" | "ParseResult" | "Locale" | "AnyValue"
  | "Output" | "Input" | "NamedValue" ) $PUS

Value ::= (Constructor | "null" $NUL | $CON PredefinedConstant $PUS | Increment
  | Method | VariableReference | KeyParameterReference | Literal | AttributeName
  | $AVE AssignmentStatement) (S? "." S? Method)?

Constructor ::= "new" $NEW S TypeIdentifier S? "(" S? ParameterList? S? ")"
  | NamedValue | ContainerValue

NamedValue ::= KeyName S? "=" S? Expression

ContainerValueStart ::= (NamedValue (S? "," S? NamedValue)* ) | Expression

ContainerValue ::= "[" S? (ContainerValueStart (S? "," S? Expression)* )? S? "]"

KeyParameterReference ::= KeyName

Method ::= $MET (SchemaTypeName | (QualifiedIdentifier - Keyword)) $PUS
  S? ("(" S? ParameterList? S? ")")? $CAL

SchemaTypeName ::= "xs:" Identifier

Increment ::= ("++" $INB | "--" $DEB) S? VariableReference 
  | $INA VariableReference S? "++" | $DEA VariableReference S? "--"
  /* The variable must be declared as an integer or a float */

Parameter ::= Expression $PAR

ParameterList ::= Parameter (S? "," S? Parameter)*

VariableReference ::= $VRF (Identifier - TypeIdentifier) $PUS

MethodDeclaration ::= $SDM ("void" $VOI | TypeIdentifier)
  S DeclaredMethodName S? ParameterListDeclaration S? Block $EDM

DeclaredMethodName ::= Identifier $PUS

ParameterListDeclaration ::=
  "(" S? (SeqParameter (S? "," S? SeqParameter)* )? ")" $EDP

SeqParameter ::= TypeIdentifier S ParameterName

KeyParameter ::= KeyName S? "=" S? (TypeIdentifier | ConstantExpression)

ParameterName ::= Identifier

ParentalExpression ::= S? "(" S? Expression S? ")" S?

StatementExpression ::= Expression

/******************************************************************************/ 
/* Script statement                                                           */
/******************************************************************************/

Statement ::= S? (Statement1 | Statement2)

Statement1 ::= (Block | SwitchStatement | TryStatement) 

Statement2 ::= (IfStatement | ForStatement | WhileStatement | DoStatement
  | ReturnStatement | ThrowStatement | BreakStatement | ContinueStatement
  | Method | Increment | AssignmentStatement S? (";" S? | $eos)? )
  $INF | EmptyStatement

EmptyStatement ::= ";"

StatementSequence ::= (S? VariableDeclaration S? ";" S? | Statement)*

Block ::= "{" StatementSequence S? "}"
 
SimpleStatement ::= S? (Statement1 | (Statement2? S? ";" S?)) | EmptyStatement

IfStatement ::=
  "if" ParentalExpression SimpleStatement (S? "else" S? SimpleStatement)?
  /* Result of ParentalExpression must be boolean. */

ForStatement ::= "for" S? "(" S?  ForInit? S? ";" S? 
  Expression? S? ";" S? ForStep? S? ")" S? SimpleStatement

ForInit ::= AssignmentStatement | VariableDeclaration

ForStepStatement ::= Method | Increment | AssignmentStatement

ForStep ::= ForStepStatement (S? "," S? ForStepStatement)*

WhileStatement ::= "while" ParentalExpression SimpleStatement
  /* Result of ParentalExpression must be boolean. */

DoStatement ::= "do" S? Statement S? "while" ParentalExpression
  /* Result of ParentalExpression must be boolean. */

SwitchStatement ::=
  "switch" ParentalExpression "{" SwitchBlockStatementVariant* S? "}"
  /* Result of ParentalExpression must be integer. Any variant may occur in the
     switch statement only once. */

SwitchBlockStatementVariant ::=
   S? ("default" S? | "case" S? ConstantExpression) S? ":" S? StatementSequence?
  /* Type  of ConstantExpression must be integer. */

ThrowStatement ::= "throw" S? ExceptionValue

ExceptionValue ::=
  "new" S? "Exception" S? "(" S? (Expression S?)? ")" | Identifier

TryStatement ::= "try" S? "{" S? StatementSequence S? "}" S? 
  "catch" S? "(" S? "Exception" S?  Identifier S? ")" S?
  "{" S? StatementSequence S? "}"

ReturnStatement ::= "return" (S? Expression)?

BreakStatement ::= "break" (S? Identifier)?

ContinueStatement ::= "continue" (S? Identifier)?

AssignmentStatement ::= (Identifier S? ((AssignmentOperator S? Expression) |
 (("=" S? Identifier))+ S? (AssignmentOperator S? Expression)) |
  S? AssignmentOperator S? Expression)

AssignmentOperator ::= $OPA (("|" | "^" | "+" | "-" | "*" | "/" | "&"
  | "%" | "<<" | ">>>" | ">>")? "=") $PUS

VariableDeclaration ::= ("final" $FIN S | "external" $EXT S)*
  TypeIdentifier S VariableDeclarator (S? "," VariableDeclarator)*

VariableDeclarator ::= S? (AssignmentStatement | Identifier)

Occurrence ::= $INF $OCC ("required" | "optional" | "ignore" | "illegal" | "*"
  | "+" | "?" | (("occurs" S)? ("*" | "+" | "?" |
  (IntegerLiteral (S? ".." (S? ("*" | IntegerLiteral))? )? ))))
  /* The value of the second IntegerLiteral (after "..")  must be greater or
     equal to the first one. */

ExplicitCode ::= Block
  /* If result value is required it must be returned by the command
     "return value". */

/******************************************************************************/
/* Script of header of X-definition                                           */
/******************************************************************************/

XdefScript ::=
  (S? (XdefInitSection | XdefOnIllegalRoot | XdefOnXmlError | XdefOptions)* S?)?
  /* Each item can be specified only once. */

XdefInitSection ::= "init" S Statement

XdefOnIllegalRoot ::= "onIllegalRoot" S Statement

XdefOnXmlError ::= "onXmlError" S Statement

XdefOptions ::= "options" S XdefOptionsList

XdefOptionsList ::= XdefOptionItem (S? "," S? XdefOptionItem)*
  /* Each item can be specified only once. */

XdefOptionItem ::= "moreAttributes" | "moreElements" | "moreText"
  | "forget" | "notForget" | "clearAdoptedForgets"
  | "resolveEntities" | "ignoreEntities" | "resolveIncludes" | "ignoreIncludes"
  | "preserveComments" | "ignoreComments" | "acceptEmptyAttributes"
  | "preserveEmptyAttributes" | "ignoreEmptyAttributes"
  | "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces"
  | "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces"
  | "setAttrUpperCase" | "setAttrLowerCase"
  | "setTextUpperCase" | "setTextLowerCase"
  | "acceptQualifiedAttr" | "notAcceptQualifiedAttr"
  | "trimAttr" | "noTrimAttr" | "trimText" | "noTrimText"
  | "resolveEntities" | "ignoreEntities"
  | "resolveIncludes" | "ignoreIncludes"
  | "preserveComments" | "ignoreComments"

/******************************************************************************/
/* Script of text nodes and attributes                                        */
/******************************************************************************/

AttributeScript ::= ValueScript

ValueScript ::= (ValueExecutivePart* S?)?

ValueExecutivePart::= "$$$script:"? S? (ValueValidationSection | ValueInitSection
  | ValueOnTrueSection | ValueOnErrorSection | ValueOnAbsenceSection
  | ValueDefaultSection | ValueCreateSection | ValueFinallySection
  | ValueMatchSection | AttributeOptions | Reference | S | ";") S?
  /* Each item can be specified only once. */

ValueValidationSection ::= "fixed" S (Expression | Block)
  | (Occurrence S? CheckValueSpecification?) | CheckValueSpecification

CheckValueSpecification ::= ExplicitCode | ValidationExpression | TypeMethodName
  /* ExplicitCode must return a value of boolean type or ParseResult. */

ValidationExpression ::= Expression
  /* Result of ValidationExpression must be a boolean or ParseResult type. */

TypeMethodName ::= Identifier

ValueMatchSection ::= "match" S? (Expression | ExplicitCode)
  /* Expression nebo ExplicitCode must here return a value of boolean type. */

ValueInitSection ::= "init" S? (ExplicitCode | Statement)

ValueOnTrueSection ::= "onTrue" S? (ExplicitCode | Statement)
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnErrorSection ::= ("onError" | "onFalse") S? (ExplicitCode | Statement)

ValueOnAbsenceSection ::= "onAbsence" S (ExplicitCode | Statement)

ValueCreateSection ::= "create" S? (ExplicitCode | ValueCreateExpression)
  /* ExplicitCode must return a value of String type. */

ValueCreateExpression ::= Expression
  /* ValueCreateExpression must return a value of String type. */

ValueDefaultSection ::= "default" S? (ExplicitCode | Expression)
  /* Expression nebo ExplicitCode must return the value of the String. */

ValueFinallySection ::= "finally" S? (ExplicitCode | Statement)

AttributeOptions ::= ValueOptions

ValueOptions ::= "options" S? ValueOptionsList

ValueOptionsList ::=  ValueOption (S? "," S? ValueOption)*
  /* Each item can be specified only once. */

ValueOption ::= "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces"
  | "setTextUpperCase" | "setTextLowerCase" | "trimText" | "noTrimText"
  | "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces" | "cdata"
  | "setAttrUpperCase" | "setAttrLowerCase" | "trimAttr" | "noTrimAttr"
  | "ignoreEmptyAttributes" | "acceptEmptyAttributes"
  | "acceptQualifiedAttr" | "notAcceptQualifiedAttr" | "preserveTextCase"

/******************************************************************************/
/* Script of elements                                                         */
/******************************************************************************/

ElementScript ::= $INF $ELE ElementExecutivePart* S?

ElementExecutivePart ::= "$$$script:"? S? (TemplateSection | Occurrence
  | ElementVarSection | ElementMatchSection | ElementInitSection
  | ElementOnAbsenceSection | ElementOnExcessSection | ElementCreateSection
  | ElementFinallySection | ElementOptions | Reference | ElementForgetSection
  | ElementOnStartSection | ElementStructureCompare | ";")
  
  
  /* Each item can be specified only once. 
   * If the occurrence is not specified, the implicite value is "required" */

TemplateSection ::= "template"

ElementVarSection ::= "var" S? 
  (("{"(S? ElementVarSectionItem S?)* "}") | ElementVarSectionItem S?)
  
ElementVarSectionItem ::= TypeDeclaration | VariableDeclaration S? ";"  | S? ";"

ElementInitSection ::= "init" S? Statement?

ElementMatchSection ::= "match" S? (Expression | ExplicitCode)
  /* Expression nebo ExplicitCode must here return a value of boolean type. */

ElementOnStartSection ::= "onStartElement" S? Statement?

ElementOnExcessSection ::= "onExcess" S? Statement?

ElementOnAbsenceSection ::= "onAbsence" S? Statement?

ElementCreateSection ::= "create" ElementCreateCode

ElementCreateCode ::= S? (Expression | ExplicitCode) S? 
  /* Expression nebo ExplicitCode must return value of Container or Element. */

ElementFinallySection ::= "finally" S? Statement?

ElementForgetSection ::= "forget"

ElementStructureCompare ::= ("implements" | "uses") S XPosition

ElementOptions ::= "options" S? ElementOptionsList

ElementOptionsList ::=  ElementOptionItem (S?  "," S? ElementOptionItem)*
  /* Each item can be specified only once. */

ElementOptionItem ::= "moreAttributes" | "moreElements" | "moreText"
  | "forget" | "notForget" | "acceptEmptyAttributes" | "clearAdoptedForgets"
  | "preserveEmptyAttributes" | "ignoreEmptyAttributes"
  | "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces"
  | "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces" | "setAttrUpperCase"
  | "setAttrLowerCase" | "setTextUpperCase" | "setTextLowerCase"
  | "acceptQualifiedAttr" | "notAcceptQualifiedAttr" | "trimAttr" | "noTrimAttr"
  | "trimText" | "noTrimText" | "resolveEntities" | "ignoreEntities"
  | "resolveIncludes" | "ignoreIncludes" | "preserveComments" | "ignoreComments"
  | "preserveTextCase" | "acceptOther" | "ignoreOther"
  | "nillable" | "noNillable"

/******************************************************************************/
/* Script of the declaration part                                             */
/******************************************************************************/

DeclarationScript ::= (S? (TypeDeclaration | ExternalMethodDeclaration
  | VariableDeclaration | MethodDeclaration | ";"))* S?

TypeDeclaration ::= ("type" S Identifier S?
  ((Identifier (S? "," S? Identifier)* S? ";" S? )
  | TypeDeclarationBody)) | UniqueSetDeclaration

TypeDeclarationBody ::= Expression
  /* Expression or ExplicitCode must return value of boolean or ParseResult.*/

ExternalMethodDeclaration ::= "external" S "method"
  ( S? "{" S? (MethodListItem S? ";" S? )* MethodListItem? S? ";"? S? "}"
  | (S MethodListItem) ) S? ";"?

UniqueSetDeclaration ::= "uniqueSet" S Identifier S? UniqueSetDeclarationBody

UniqueSetDeclarationBody ::=
  ("{" S? UniqueSetKey (S?";"S? (UniqueSetVar|UniqueSetKey))* (S?";"S?)? S? "}")
  | (Method UniqueSetVar?)
  /* Expression or ExplicitCode must return value of boolean or ParseResult.
  */
  
UniqueSetKey ::= S? Identifier (S?":"S? (("?" | "optional") S? )? Method )?

UniqueSetVar ::= S? "var" S TypeIdentifier S Identifier
  (S? "," S? TypeIdentifier S Identifier)*
      
/******************************************************************************/
/* BNF grammar                                                                */
/******************************************************************************/

BNFGrammar ::= S? BNFMethodDeclarationSection? BNFRules S?

BNFMethodDeclarationSection ::= BNFMethodDeclaration (S? BNFMethodDeclaration)*

BNFRuleName ::= RawIdentifier

BNFDefinedMethodName ::= "$" (BNFRuleName | Digit+)

BNFRuleDecl ::= S? BNFRuleName S? "::=" S? 

BNFRuleReference ::= BNFDefinedMethodName | (BNFRuleName - BNFRuleDecl)

BNFMethodDeclaration ::= "%define" S BNFDefinedMethodName S? ":"
  S ("$" QualifiedIdentifier | BNFDefinedMethodName) S? BNFMethodparameters?

BNFMethodparameters ::= "(" S?
  (BNFMethodparameter (S? "," S? BNFMethodparameter)* ) ? S? ")"

BNFMethodparameter ::= Digit+ | BNFTerminalSymbol

BNFTerminalSymbol ::= "'" [^']* "'" | '"' [^"]* '"' 
  | (BNFHexaChracter (S? BNFHexaChracter)* )

BNFHexaChracter ::= "#" HexaDigit+

BNFRules ::= BNFRule (BNFRule)*

BNFRule ::= BNFRuleDecl BNFExpression

BNFQuantifier ::= S? ("+" | "*" | "?" | BNFExplicitQuantifier)

BNFExplicitQuantifier ::= "{" S? Digit+ (S? "," S? Digit+)? S? "}" 

BNFSet ::= "[" ("^"? Char - "]")* "]" BNFQuantifier?

BNFTerm ::= (BNFTerminalSymbol | BNFSet | BNFRuleReference) BNFQuantifier?
  | BNFParentalExpr

BNFParentalExpr ::= "(" S? BNFExpr S? ")" S? BNFQuantifier?

BNFSequence ::= BNFTerm (S? BNFTerm)* 

BNFRestriction ::= BNFSequence (S? "-" S? BNFTerm)?

BNFExpr ::= BNFRestriction (S? "|" S? BNFRestriction)*

BNFExpression ::= (BNFExpr S?)+ 

/******************************************************************************/ 
/* XComponent                                                                 */
/******************************************************************************/

JavaTypeName ::= '<' S? $JavaQName (S? JavaTypeName)?
  (S? "," S?  JavaTypeName)* S? '>'

JavaTypedQName ::= $JavaQName (S? JavaTypeName)?

XCComponent ::= S? (XCComponentCommand
  (S? ";" S? XCComponentCommand?)* )

XCComponentCommand ::= (XCBind | XCClass | XCEnum | XCInterface | XCRef)

XCBind ::= "%bind" S XMLName (S "%with" S $JavaQName)? S XCLink

XCClass ::= "%class" S JavaTypedQName (S "extends" S JavaTypedQName)?
  (S "implements" S JavaTypedQName (S? "," S? JavaTypedQName)* )?
  (S "%interface" S JavaTypedQName)? S XCLink

XCEnum ::= "%enum" S JavaTypedQName S (Identifier? "#")? XMLName

XCInterface ::= "%interface" S $JavaQName S XCLink

XCRef ::= "%ref" S ((JavaTypedQName S XCLink)
  | ("%enum" S JavaTypedQName S (Identifier? "#")? XMLName))

XCLink ::= "%link" S ("*" | XPosition)

]]>
  </xd:BNFGrammar>

</xd:def>