<?xml version="1.0" encoding="UTF-8"?>
<!-- Metanamespace of XDefinition: "METAXD" is 3.1 -->
<xd:def xmlns:xd  = "METAXD"
  xmlns:w         = "http://www.syntea.cz/xdef/3.1"
  xmlns:XD2.0     = "http://www.syntea.cz/xdef/2.0"
  xmlns:XD3.1     = "http://www.syntea.cz/xdef/3.1"
  w:metaNamespace = "METAXD"
  xd:root         = "Ver2.0#XD2.0:def | Ver2.0#XD2.0:collection 
                     | Ver3.1#XD3.1:def | Ver3.1#XD3.1:collection" >

<xd:declaration>
  /* Default namespace of XDefinition */
  String xdUri;
  /* Variable id used as the namespace of checked source; default is xdUri.*/
  String NS;

/******************************************************************************/
/* Types of values see BNF grammar below                                      */
/******************************************************************************/
  type rootList XDScript.rule('RootList');
  type xdefScript XDScript.rule('XdefScript');
  type declarationScript XDScript.rule('DeclarationScript');
  type valueScript XDScript.rule('ValueScript');
  type attributeScript XDScript.rule('AttributeScript');
  type elementScript XDScript.rule('ElementScript');
  type groupScript XDScript.rule('ElementScript');
  type groupModelScript XDScript.rule('ElementScript');
  type Occurrence XDScript.rule('Occurrence');
  type elementCreateExpression XDScript.rule('ElementCreateSection');
  type xdIdentifier XDScript.rule('Identifier');
  type xposition XDScript.rule('XPosition');
  type booleanLiteral XDScript.rule('BooleanLiteral');
  type bnfGrammar XDScript.rule('BNFGrammar');
  type xcomponent XDScript.rule('XCComponent');

  /** Check element name and namespace URI (used in the match section) */
  boolean xdName(String name) {
    return getElementLocalName() EQ name AND getNamespaceURI() EQ NS;
  }
</xd:declaration>

/******************************************************************************/
/* Declaration of BNF grammar of Script                                       */
/******************************************************************************/

  <xd:BNFGrammar name = "XDScript">
<![CDATA[
/******************************************************************************/
/* Generate codes                                                             */
/******************************************************************************/
%define $PUS: $push       /* put parsed source to internal stack. */
%define $POS: $pos        /* put actual source position to internal stack. */

%define $OPA: $push('OPA') /* assignment operation */
%define $OPU: $push('OPU') /* unary operators */
%define $OP1: $push('OP1') /* operators level 1 */
%define $OP2: $push('OP2') /* operators level 2 */
%define $OP3: $push('OP3') /* operators level 3 */
%define $OP4: $push('OP4') /* operators level 4 */
%define $OP5: $push('OP5') /* operators level 5 */
%define $TYP: $push('TYP') /* name the type of a value */
%define $CON: $push('CON') /* constant name */
%define $NUL: $push('NUL') /* null */
%define $NEW: $push('NEW') /* new */
%define $VRF: $push('VRF') /* variable reference */
%define $NMI: $push('NMI') /* integer number */
%define $NMF: $push('NMF') /* floating point number */
%define $TRU: $push('TRU') /* true */
%define $FAL: $push('TRU') /* false */
%define $STR: $push('STR') /* string literal */
%define $INB: $push('INB') /* increase before: ("++") variable */
%define $INA: $push('INA') /* increase after: variable ("++") */
%define $DEB: $push('DEB') /* decrease before: ("--") variable */
%define $DEA: $push('DEA') /* decrease after: variable ("--") */

%define $FIN: $push('FIN') /* modifier "final" */
%define $EXT: $push('EXT') /* modifier "external" */

%define $FIX: $push('FIX') /* "fixed" value occurrence */

%define $ELE: $push('ELE') /* script of "xd:script" of element */
%define $OCC: $push('OCC') /* Occurrence */

/******************************************************************************/
/* BNF grammar rules                                                          */
/******************************************************************************/

Letter ::= $letter
Char ::= $xmlChar
WhiteSpace ::= [#9#10#13 ]
Comment ::= "/*" ( [^*]+ | "*" [^/] )* "*/"
S ::= ( WhiteSpace | Comment )+

/******************************************************************************/ 
/* Base symbols                                                               */
/******************************************************************************/

Keyword ::= "if" | "else" | "do" | "while" | "continue" | "break" | "switch"
  | "case" | "for" | "return" | "def" | "try" | "catch" | "throw" | "finally"
  | "external" | "new" | "fixed" | "required" | "optional" | "ignore"
  | "illegal" | "occurs" | "onTrue" | "onError" | "onAbsence" | "default"
  | "onExcess" | "onStartElement" | "onIllegalAttr" | "onIllegalText"
  | "onIllegalElement" | "onIllegalRoot" | "create" | "init" | "options"
  | "ref" | "match" | "final" | "forget" | "template" | "type" | "uniqueSet"
  | "EQ" | "NE" | "LT" | "LE" | "GT" | "GE"
  | "LSH" | "RSH" | "RRSH" | "AND" | "OR" | "XOR" | "MOD" | "NOT" | "NEG"
  | "OOR" | "AAND"
  | "true" | "false"
  
PredefinedConstant ::= "$PI" | "$E" | "$MAXINT" | "$MININT" | "$MINFLOAT"
  | "$MAXFLOAT" | "$NEGATIVEINFINITY" | "$POSITIVEINFINITY"

Digit ::= [0-9]

Identifier ::= ((BaseIdentifier ( ':' BaseIdentifier)? ) - Keyword)

BaseIdentifier ::= (( Letter | "_" | "$")  ( Letter | Digit | "_" )*)

RawIdentifier ::= ( Letter | "_")  ( Letter | Digit | "_" )*

QualifiedIdentifier ::= BaseIdentifier ( "." BaseIdentifier )+ | BaseIdentifier

BooleanLiteral ::= ($TRU "true" | $FAL "false")

DecimalInteger ::= ( Digit ("_")* )+

HexaDigit ::= Digit | [a-fA-F]

IntegerLiteral ::= $NMI ( ( "0" [Dd] )? DecimalInteger
  | "0" [Xx] (HexaDigit ("_")* )+ ) $PUS
/* Inside a number specification it is possible to insert the character "_".
  This character does not influence the value of the number, it just makes 
  a number more readable. E.g. the number 123456789 you can be written
  as 123_456_789 (or 0x0f123456 as 0x0f_12_34_56). */

FloatLiteral ::= $NMF (DecimalInteger ( "." DecimalInteger Exponent? 
  | Exponent)) $PUS 

Exponent ::= [Ee] [-+]? [0-9]+

NumberLiteral ::= FloatLiteral | IntegerLiteral

SpecChar ::= "\" ("\" | '"' | "'" | "n" | "r" | "t" ) | UnicodeCharSpecification

UnicodeCharSpecification ::= "\u" HexaDigit{4}

StringLiteral ::= $STR ("'" ( "''" | [^'\] | SpecChar)* "'" |
  '"' ( '""' | [^"\] | SpecChar)* '"') $PUS
  /* The opening and closing delimiter must be either """ or "'". The occurrence
     of this delimiter inside of literal can be recorded as double delimiter or
     in the form of SpecChar. */

Literal ::= BooleanLiteral | NumberLiteral | StringLiteral

XMLName ::= $xmlName /* XMLName see XML specification */

KeyName ::= "%" XMLName

AttributeName ::= "@" XMLName

Reference ::= "ref" S XPosition

XDefName ::= XMLName

XModelName ::= XMLName

XPosition ::= (XDefName? "#")? XModelName
  ("/" (XMLName | XGroupRererence | XAnyReference) XPositionIndex? )*
  ("/" ( XAttrReference | XTextReference ) )?

XPositionIndex ::= "[" Digit+ "]"

XGroupRererence ::= "$mixed" | "$choice" | "$sequence"

XAnyReference ::= "$any"

XAttrReference ::= "@" XMLName

XTextReference ::= "$text" XPositionIndex?

RootList ::= S? RootSpecification ( S? "|" S? RootSpecification )* S?
  /* all rootspecification in the list must be unique */

RootSpecification ::= XPosition | "*"

MethodListItem ::= Identifier S? 
  QualifiedIdentifier S? "(" S? MethodListItemParamList? S? ")" S?
  ( "as" S? Identifier )?
  
MethodListItemParamList ::= QualifiedIdentifier (S?"[" S? "]")?
  (S? "," S? QualifiedIdentifier (S?"[" S? "]")?)*

MacroReference ::= "${" S? XMLName S? MacroParams? S? "}"

MacroParams ::= "(" S? Identifier ( S? "," S? Identifier)* S? ")"

/******************************************************************************/
/* Script expression                                                          */
/******************************************************************************/

Expression ::= Expr1 (S? "?" S? Expression S? ":" S? Expression )?

OperatorLevel_1 ::= $OP1 ("OR" | "OOR" | "XOR" | "||" | "|" | "^") $PUS

Expr1 ::= Expr2 (S? OperatorLevel_1 S? Expr2 )*

OperatorLevel_2 ::= $OP2 ("AND" | "AAND" | "&&" | "&") $PUS

Expr2 ::= Expr3 (S?  OperatorLevel_2 S? Expr3 )*

OperatorLevel_3 ::= $OP3 ("LT" | "<" | "GT" | ">" | "==" | "EQ" | "LE"
  | "<=" | "GE" | ">=" | "!=" | "NE" | "<<" | "LSH" | ">>" | "RSH" | ">>>"
  | "RRSH") $PUS

Expr3 ::= Expr4 (S? OperatorLevel_3 S? Expr4 )*

OperatorLevel_4 ::= $OP4 ("*" | "/" | "%") $PUS

Expr4 ::= Expr5 (S? OperatorLevel_4 S? Expr5 )*

OperatorLevel_5 ::= $OP5 ("+" | "-") $PUS

Expr5 ::= Expr (S? OperatorLevel_5 S? Expr )*

Expr ::= (UnaryOperator S? | CastRequest S?)*
  (Value | Literal | "(" S? Expression S? ")") (S? "." S? Method)?

ConstantExpression ::= Literal /* ConstantExpression must be a Literal. */

CastRequest ::= S? "(" S? TypeIdentifier S? ")" S?

UnaryOperator ::= "+" | $OPU ("-" | "!" | "NOT" | "~") $PUS

TypeIdentifier ::= $TYP ("int" | "String" | "float" | "boolean" | "Datetime"
  | "Decimal" | "Duration" | "Exception" | "Container" | "Element" | "Message"
  | "Bytes" | "XmlOutStream" | "BNFGrammar" | "BNFRule" | "Parser"
  | "ParseResult" | "AnyValue") $PUS

Value ::= Constructor | "null" $NUL | $CON PredefinedConstant $PUS | Increment
  | Method | VariableReference | KeyParameterReference | Literal | AttributeName

Constructor ::= "new" $NEW S TypeIdentifier S? "(" S? ParameterList? S? ")"
  | NamedValue | ContainerValue

NamedValue ::= KeyName S? "=" S? Expression

ContainerValueStart ::= (NamedValue (S? "," S? NamedValue)*) | Expression

ContainerValue ::= "[" S? (ContainerValueStart (S? "," S? Expression)*)? S? "]"

KeyParameterReference ::= KeyName

Method ::= $VRF (QualifiedIdentifier - Keyword) $PUS S? ("(" S? ParameterList? S? ")")?

Increment ::= ("++" $INB | "--" $DEB) S? VariableReference 
  | $INA VariableReference S? "++" | $DEA VariableReference S? "--"
  /* The variable must be declared as an integer or a float */

ParameterList ::= (Expression) (S? "," S? Expression)*

VariableReference ::= $VRF (Identifier - TypeIdentifier) $PUS

MethodDeclaration ::=
  ( "void" | TypeIdentifier ) S MethodName S? ParameterListDeclaration S? Block

MethodName ::= QualifiedIdentifier

ParameterListDeclaration ::=
  "(" S? ( SeqParameter (S? "," S? SeqParameter )* )? ")"

SeqParameter ::= TypeIdentifier S ParameterName

KeyParameter ::= KeyName S? "=" S? (TypeIdentifier | ConstantExpression)

ParameterName ::= Identifier

ParentalExpression ::= S? "(" S? Expression S? ")" S?

StatementExpression ::= Expression

/******************************************************************************/ 
/* Script statement                                                           */
/******************************************************************************/

Statement ::= S? (Statement1 | Statement2)

Statement1 ::= Block | SwitchStatement | TryStatement 

Statement2 ::= ( IfStatement | ForStatement | WhileStatement | DoStatement
  | ReturnStatement | ThrowStatement | BreakStatement | ContinueStatement
  | Method | Increment | AssignmentStatement S? ";" ) | EmptyStatement

EmptyStatement ::= ";"

StatementSequence ::= ( S? VariableDeclaration S? ";" | Statement)*

Block ::= "{" StatementSequence S? "}"

SimpleStatement ::= S? (Statement1 | (Statement2? S? ";" S?)) | EmptyStatement

IfStatement ::=
  "if" ParentalExpression SimpleStatement ( S? "else" S? SimpleStatement)?
  /* Result of ParentalExpression must be boolean. */

ForStatement ::= "for" S? "(" S?  ForInit? S? ";" S? 
  Expression? S? ";" S? ForStep? S? ")" S? SimpleStatement

ForInit ::= AssignmentStatement | VariableDeclaration

ForStepStatement ::= Method | Increment | AssignmentStatement

ForStep ::= ForStepStatement (S? "," S? ForStepStatement)*

WhileStatement ::= "while" ParentalExpression SimpleStatement
  /* Result of ParentalExpression must be boolean. */

DoStatement ::= "do" S? Statement S? "while" ParentalExpression
  /* Result of ParentalExpression must be boolean. */

SwitchStatement ::=
  "switch" ParentalExpression "{" SwitchBlockStatementVariant* S? "}"
  /* Result of ParentalExpression must be integer. Any variant may occur in the
     switch statement only once. */

SwitchBlockStatementVariant ::=
   S? ("default" S? | "case" S? ConstantExpression) S? ":" S? StatementSequence?
  /* Type  of ConstantExpression must be integer. */

ThrowStatement ::= "throw" S? ExceptionValue

ExceptionValue ::=
  "new" S? "Exception" S? "(" S? (Expression S?)? ")" | Identifier

TryStatement ::= "try" S? "{" S? StatementSequence S? "}" S? 
  "catch" S? "(" S? "Exception" S?  Identifier S? ")" S?
  "{" S? StatementSequence S? "}"

ReturnStatement ::= "return" (S? Expression)?

BreakStatement ::= "break" (S? Identifier)?

ContinueStatement ::= "continue" (S? Identifier)?

AssignmentStatement ::= Identifier S? ((AssignmentOperator S? Expression) |
 (("=" S? Identifier))+ S? (AssignmentOperator S? Expression)) |
  S? AssignmentOperator S? Expression

AssignmentOperator ::= $OPA (("|" | "^" | "+" | "-" | "*" | "/" | "&"
  | "%" | "<<" | ">>>" | ">>")? "=") $PUS

VariableDeclaration ::= ("final" $FIN S | "external" $EXT S )*
  TypeIdentifier S VariableDeclarator (S? "," VariableDeclarator)*

VariableDeclarator ::= S? (AssignmentStatement | Identifier)

Occurrence ::= $POS $OCC ("required" | "optional" | "ignore" | "illegal" | "*"
  | "+" | "?" | (("occurs" S)? ("*" | "+" | "?" |
  (IntegerLiteral (S? ".." (S? ( "*" | IntegerLiteral))? )?))))
  /* The value of the second IntegerLiteral (after "..")  must be greater or
     equal to the first one. */

ExplicitCode ::= Block
  /* If result value is required it must be returned by the command
     "return value". */

/******************************************************************************/
/* Script of header of X-definition                                           */
/******************************************************************************/

XdefScript ::=
  S? ( XdefInitSection | XdefOnIllegalRoot | XdefOnXmlError | XdefOptions )* S?
  /* Each item can be specified only once. */

XdefInitSection ::= "init" S Statement

XdefOnIllegalRoot ::= "onIllegalRoot" S Statement

XdefOnXmlError ::= "onXmlError" S Statement

XdefOptions ::= "options" S XdefOptionsList

XdefOptionsList ::= XdefOptionItem ( S? "," S? XdefOptionItem )*
  /* Each item can be specified only once. */

XdefOptionItem ::= "moreAttributes" | "moreElements" | "moreText"
  | "forget" | "notForget" | "clearAdoptedForgets"
  | "resolveEntities" | "ignoreEntities" | "resolveIncludes" | "ignoreIncludes"
  | "preserveComments" | "ignoreComments" | "acceptEmptyAttributes"
  | "preserveEmptyAttributes" | "ignoreEmptyAttributes"
  | "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces"
  | "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces"
  | "setAttrUpperCase" | "setAttrLowerCase"
  | "setTextUpperCase" | "setTextLowerCase"
  | "acceptQualifiedAttr" | "notAcceptQualifiedAttr"
  | "trimAttr" | "noTrimAttr" | "trimText" | "noTrimText"
  | "resolveEntities" | "ignoreEntities"
  | "resolveIncludes" | "ignoreIncludes"
  | "preserveComments" | "ignoreComments"

/******************************************************************************/
/* Script of text nodes and attributes                                        */
/******************************************************************************/

AttributeScript ::= ValueScript S?

ValueScript ::= ValueExecutivePart*

ValueExecutivePart::= S? ( ValueValidationSection | ValueInitSection
  | ValueOnTrueSection | ValueOnErrorSection | ValueOnAbsenceSection
  | ValueDefaultSection | ValueCreateSection | ValueFinallySection
  | AttributeOptions | Reference | S | ";" ) S?
  /* Each item can be specified only once. */

ValueValidationSection ::= "fixed" S (Expression | Block)
  | (Occurrence S? CheckValueSpecification?) | CheckValueSpecification

CheckValueSpecification ::= ExplicitCode | Expression | TypeMethodName
  /* Expression or ExplicitCode must return a value of boolean type. */

TypeMethodName ::= Identifier

ValueInitSection ::= "init" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnTrueSection ::= "onTrue" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnErrorSection ::= "onError" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueOnAbsenceSection ::= "onAbsence" S ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

ValueCreateSection ::= "create" S? ( ExplicitCode | Expression )
  /* Expression nebo ExplicitCode must return the value of String. */

ValueDefaultSection ::= "default" S? ( ExplicitCode | Expression )
  /* Expression nebo ExplicitCode must return the value of the String. */

ValueFinallySection ::= "finally" S? ( ExplicitCode | Statement )
  /* If Method or ExplicitCode returns a value, it will be ignored. */

AttributeOptions ::= ValueOptions

ValueOptions ::= "options" S? ValueOptionsList

ValueOptionsList ::=  ValueOption ( S? "," S? ValueOption )*
  /* Each item can be specified only once. */

ValueOption ::= "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces"
  | "setTextUpperCase" | "setTextLowerCase" | "trimText" | "noTrimText"
  | "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces"
  | "setAttrUpperCase" | "setAttrLowerCase" | "trimAttr" | "noTrimAttr"
  
/******************************************************************************/
/* Script of elements                                                         */
/******************************************************************************/

ElementScript ::= $POS $ELE ElementExecutivePart* S?

ElementExecutivePart ::= S? ( Occurrence | ElementVarSection
  | ElementMatchSection| ElementInitSection | ElementOnAbsenceSection
  | ElementOnExcessSection | ElementCreateSection | ElementFinallySection
  | ElementOptions | Reference | ElementForgetSection | ElementOnStartSection |
  S | ";" )
  /* Each item can be specified only once. 
   * If the occurrence is not specified, the implicite value is "required" */

ElementVarSection ::= "var" S? 
  (("{"(S? ElementVarSectionItem S?)* "}") | ElementVarSectionItem S?)
  
ElementVarSectionItem ::= TypeDeclaration | VariableDeclaration S? ";"  | S? ";"

ElementInitSection ::= "init" S? Statement?

ElementMatchSection ::= "match" S? ( Expression | ExplicitCode )
  /* Expression nebo ExplicitCode must return value of boolean. */

ElementOnStartSection ::= "onStartElement" S? Statement?

ElementOnExcessSection ::= "onExcess" S? Statement?

ElementOnAbsenceSection ::= "onAbsence" S? Statement?

ElementCreateSection ::= "create" S? (Expression | ExplicitCode)
  /* Expression nebo ExplicitCode must return value of Container or Element. */

ElementFinallySection ::= "finally" S? Statement?

ElementForgetSection ::= "forget"

ElementOptions ::= "options" S? ElementOptionsList

ElementOptionsList ::=  ElementOptionItem ( S?  "," S? ElementOptionItem )*
  /* Each item can be specified only once. */

ElementOptionItem ::= "moreAttributes" | "moreElements" | "moreText"
  | "forget" | "notForget" | "acceptEmptyAttributes" | "clearAdoptedForgets"
  | "preserveEmptyAttributes" | "ignoreEmptyAttributes"
  | "preserveAttrWhiteSpaces" | "ignoreAttrWhiteSpaces"
  | "preserveTextWhiteSpaces" | "ignoreTextWhiteSpaces" | "setAttrUpperCase"
  | "setAttrLowerCase" | "setTextUpperCase" | "setTextLowerCase"
  | "acceptQualifiedAttr" | "notAcceptQualifiedAttr" | "trimAttr" | "noTrimAttr"
  | "trimText" | "noTrimText" | "resolveEntities" | "ignoreEntities"
  | "resolveIncludes" | "ignoreIncludes" | "preserveComments" | "ignoreComments"
  | "nillable" | "noNillable"

/******************************************************************************/
/* Script of the declaration part                                             */
/******************************************************************************/

DeclarationScript ::= (S? ( TypeDeclaration | ExternalMethodDeclaration
  | VariableDeclaration S? ";" | MethodDeclaration | ";" ) )* S?

TypeDeclaration ::= ( "type" S Identifier S?
  ( (Identifier (S? "," S? Identifier)* S? ";" S?) | TypeDeclarationBody ) )
  | ("uniqueSet" S Identifier S?  UniqueSetDeclarationBody )

TypeDeclarationBody ::= Expression
  /* Expression or ExplicitCode must return value of boolean or ParseResult.*/

ExternalMethodDeclaration ::= "external" S "method" 
  (S MethodListItem S? ";" )?
  | (S? "{" S? ( MethodListItem (S? ";" S? MethodListItem ?)* )? "}" )

UniqueSetDeclarationBody ::= ("{" S? Identifier S? ":" S? "?"? S? Expression
  (S? ";" S? S? Identifier S? ":" S? "?"? S? Expression)? S? ";"? S? "}")
  | Expression
  /* Expression or ExplicitCode must return value of boolean or ParseResult.*/

/******************************************************************************/ 
/* BNF grammar                                                                */
/******************************************************************************/

BNFGrammar ::= S? BNFMethodDeclarationSection? S? BNFRules S?

BNFMethodDeclarationSection ::= BNFMethodDeclaration (S? BNFMethodDeclaration)*

BNFRuleName ::= RawIdentifier

BNFExternalRuleName ::= "$" BNFRuleName

BNFRuleReference ::= BNFExternalRuleName | BNFRuleName

BNFMethodDeclaration ::= "%define" S BNFExternalRuleName S ":"
 S "$" QualifiedIdentifier BNFMethodparameters?

BNFMethodparameters ::= "(" S? BNFMethodparameter
 (S? "," S? BNFMethodparameter)* S? ")"

BNFMethodparameter ::= Digit+ | BNFTerminalSymbol

BNFTerminalSymbol ::= "'" (Char - "'")* "'" | '"' (Char - '"')* '"' 
  | BNFHexaChracter (S? BNFHexaChracter)*

BNFHexaChracter ::= "#x" HexaDigit+

BNFRules ::= BNFRule (S BNFRule)*

BNFRule ::= BNFRuleName S? "::=" S? BNFExpression

BNFQuantificator ::= S? ("+" | "*" | "?" | BNFExplicitQuantificator)

BNFExplicitQuantificator ::= "{" S? Digit+ (S? "," S? Digit+)? S? "}" 

BNFExpression ::= ( "(" S? BNFExpression  S? ")" (S? BNFQuantificator)?
  | BNFRestriction | BNFSelection | BNFSequence ) - ( BNFRuleName S? "::=" )

BNFSet ::= "[" BNFSetBody "]"

BNFSetBody ::= ("^"? Char - "]")+

BNFTerm ::= (BNFTerminalSymbol | BNFSet | BNFRuleReference)
  (S? BNFQuantificator)?

BNFSequence ::= BNFTerm ( S BNFExpression )*

BNFRestriction ::= BNFTerm S? "-" S? BNFExpression

BNFSelection ::= BNFTerm ( S? "|" S? BNFExpression )+

/***************************************************************************** 
* XComponent
******************************************************************************/

JavaTypeName ::= '<' S? $JavaQName (S? JavaTypeName )?
     (S? "," S?  JavaTypeName)* S? '>'

JavaTypedQName ::= $JavaQName ( S? JavaTypeName )?

/*JavaTypeName ::= '<' $JavaQName JavaTypeName* ("," JavaTypeName)* '>'

JavaTypedQName ::= $JavaQName JavaTypedQName?*/

XCComponent ::= S? ( XCComponentCommand
 (S? ";" S? XCComponentCommand?)* ) 

XCComponentCommand ::= (XCBind | XCClass | XCEnum | XCInterface | XCRef)

XCBind ::= "%bind" S XMLName ( S "%with" S $JavaQName )? S XCLink

XCClass ::= "%class" S JavaTypedQName (S "extends" S JavaTypedQName )?
  (S "implements" S JavaTypedQName (S? "," S? JavaTypedQName)*)?
  (S "%interface" S JavaTypedQName)? S XCLink

XCEnum ::= "%enum" S JavaTypedQName S (Identifier? "#")? XMLName

XCInterface ::= "%interface" S $JavaQName S XCLink

XCRef ::= "%ref" S JavaTypedQName S XCLink

XCLink ::= "%link" S ("*" /*any*/ | XPosition)

]]>
  </xd:BNFGrammar>

</xd:def>